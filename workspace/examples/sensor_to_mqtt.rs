//! # Sensor to MQTT Integration Example\n//!\n//! A simplified example showing how to read BME280 sensor data and publish it via MQTT.\n//! This example focuses on the core sensor-to-cloud data flow without additional complexity.\n//!\n//! ## Features Demonstrated\n//!\n//! - BME280 sensor initialization and reading\n//! - WiFi connectivity establishment\n//! - MQTT broker connection\n//! - Periodic sensor data publishing\n//! - Error handling with iot-common\n//!\n//! ## Hardware Requirements\n//!\n//! - ESP32-C3 DevKit board\n//! - BME280 sensor (I2C: GPIO8=SDA, GPIO9=SCL)\n//! - WiFi network access\n//! - MQTT broker (local or cloud)\n//!\n//! ## Configuration\n//!\n//! Create `.cargo/config.toml` with:\n//!\n//! ```toml\n//! [env]\n//! WIFI_SSID = \"YourNetwork\"\n//! WIFI_PASSWORD = \"YourPassword\"\n//! MQTT_BROKER = \"192.168.1.100\"\n//! ```\n//!\n//! ## Expected Output\n//!\n//! The system publishes JSON messages to `esp32/sensor/bme280` topic:\n//!\n//! ```json\n//! {\n//!   \"temperature\": 23.2,\n//!   \"humidity\": 68.5,\n//!   \"pressure\": 1013.8,\n//!   \"timestamp\": 1694123456,\n//!   \"device_id\": \"esp32_demo\"\n//! }\n//! ```\n\n#![no_std]\n#![no_main]\n\nuse embassy_executor::Spawner;\nuse embassy_time::{Duration, Timer};\nuse esp_hal::{\n    gpio::Io,\n    i2c::I2c,\n    peripherals::Peripherals,\n    prelude::*,\n    system::SystemControl,\n};\nuse esp_hal_embassy;\n\n// IoT modules\nuse bme280_embassy::BME280;\nuse wifi_embassy::{WiFiManager, WiFiConfig};\nuse mqtt_embassy::MqttClient;\nuse iot_common::{IoTResult, IoTError, result::IoTResultExt};\n\n// Utilities\nuse rtt_target::{rprintln, rtt_init_print};\nuse serde_json_core;\nuse heapless::String;\n\n// Configuration\nconst WIFI_SSID: &str = env!(\"WIFI_SSID\");\nconst WIFI_PASSWORD: &str = env!(\"WIFI_PASSWORD\");\nconst MQTT_BROKER: &str = env!(\"MQTT_BROKER\", \"192.168.1.100\");\nconst DEVICE_ID: &str = \"esp32_demo\";\nconst READING_INTERVAL: Duration = Duration::from_secs(10);\n\n/// Sensor data structure for JSON serialization\n#[derive(serde::Serialize)]\nstruct SensorReading {\n    temperature: f32,\n    humidity: f32,\n    pressure: f32,\n    timestamp: u64,\n    device_id: String<32>,\n}\n\n#[esp_hal_embassy::main]\nasync fn main(spawner: Spawner) -> ! {\n    // Initialize debugging\n    rtt_init_print!();\n    rprintln!(\"üöÄ Sensor to MQTT Demo Starting...\");\n    \n    // Initialize hardware\n    let (mut sensor, wifi_manager, mqtt_client) = match init_system(spawner).await {\n        Ok(components) => components,\n        Err(e) => {\n            rprintln!(\"‚ùå System initialization failed: {}\", e);\n            panic!(\"Cannot continue without initialization\");\n        }\n    };\n    \n    rprintln!(\"‚úÖ System initialized successfully\");\n    rprintln!(\"üìä Starting sensor readings every {} seconds\", READING_INTERVAL.as_secs());\n    \n    let mut reading_count = 0u32;\n    \n    // Main sensor reading and publishing loop\n    loop {\n        match read_and_publish_sensor_data(&mut sensor, &mqtt_client, &mut reading_count).await {\n            Ok(()) => {\n                rprintln!(\"‚úÖ Reading #{} published successfully\", reading_count);\n            }\n            Err(e) => {\n                rprintln!(\"‚ùå Reading #{} failed: {}\", reading_count, e);\n                \n                // Continue operation despite errors\n                // In production, you might want to implement retry logic\n            }\n        }\n        \n        Timer::after(READING_INTERVAL).await;\n    }\n}\n\n/// Initialize all system components\nasync fn init_system(\n    spawner: Spawner,\n) -> IoTResult<(BME280<'static, I2c<'static, esp_hal::peripherals::I2C0>>, WiFiManager, MqttClient)> {\n    // Hardware initialization\n    rprintln!(\"üîß Initializing hardware...\");\n    \n    let peripherals = Peripherals::take();\n    let system = SystemControl::new(peripherals.SYSTEM);\n    let clocks = esp_hal::clock::ClockControl::max(system.clock_control).freeze();\n    \n    // Initialize Embassy\n    esp_hal_embassy::init(peripherals.TIMG1);\n    \n    // Setup GPIO and I2C\n    let io = Io::new(peripherals.GPIO, peripherals.IO_MUX);\n    let i2c_config = esp_hal::i2c::Config::default().frequency(100.kHz());\n    let i2c = I2c::new(\n        peripherals.I2C0,\n        io.pins.gpio8,  // SDA\n        io.pins.gpio9,  // SCL\n        i2c_config,\n        &clocks,\n    )\n    .map_err(|_| IoTError::hardware(\n        iot_common::HardwareError::GPIOError(\n            iot_common::error::utils::error_message(\"I2C initialization failed\")\n        )\n    ))\n    .with_context(\"I2C setup\")?;\n    \n    // Initialize BME280 sensor\n    rprintln!(\"üå°Ô∏è Initializing BME280 sensor...\");\n    let mut sensor = BME280::new(i2c);\n    sensor.init().await\n        .map_err(|_| IoTError::sensor(\n            iot_common::SensorError::InitializationFailed(\n                iot_common::error::utils::error_message(\"BME280 init failed\")\n            )\n        ))\n        .with_context(\"BME280 initialization\")?;\n    \n    // Initialize WiFi\n    rprintln!(\"üì° Connecting to WiFi...\");\n    let wifi_config = WiFiConfig {\n        ssid: WIFI_SSID,\n        password: WIFI_PASSWORD,\n    };\n    \n    let wifi_manager = WiFiManager::new(\n        spawner,\n        peripherals.TIMG0,\n        peripherals.WIFI,\n        peripherals.RNG,\n        wifi_config,\n    )\n    .await\n    .map_err(|e| IoTError::network(\n        iot_common::NetworkError::WiFiConnectionFailed(\n            iot_common::error::utils::error_message(&format!(\"WiFi failed: {}\", e))\n        )\n    ))\n    .with_context(\"WiFi connection\")?;\n    \n    if let Some(info) = wifi_manager.get_connection_info() {\n        rprintln!(\"   IP: {}\", info.ip_address);\n    }\n    \n    // Initialize MQTT client\n    rprintln!(\"üì® Connecting to MQTT broker...\");\n    let mqtt_config = mqtt_embassy::MqttConfig {\n        broker_ip: MQTT_BROKER,\n        broker_port: 1883,\n        client_id: DEVICE_ID,\n        username: None,\n        password: None,\n    };\n    \n    let mqtt_client = MqttClient::new(wifi_manager.get_stack(), mqtt_config)\n        .await\n        .map_err(|e| IoTError::network(\n            iot_common::NetworkError::TCPConnectionFailed(\n                iot_common::error::utils::error_message(&format!(\"MQTT failed: {}\", e))\n            )\n        ))\n        .with_context(\"MQTT connection\")?;\n    \n    Ok((sensor, wifi_manager, mqtt_client))\n}\n\n/// Read sensor data and publish via MQTT\nasync fn read_and_publish_sensor_data(\n    sensor: &mut BME280<'static, I2c<'static, esp_hal::peripherals::I2C0>>,\n    mqtt_client: &MqttClient,\n    reading_count: &mut u32,\n) -> IoTResult<()> {\n    // Read sensor measurements\n    let measurements = sensor.read_measurements().await\n        .map_err(|_| IoTError::sensor(\n            iot_common::SensorError::I2CError(\n                iot_common::error::utils::error_message(\"BME280 read failed\")\n            )\n        ))\n        .with_context(\"Sensor measurement\")?;\n    \n    *reading_count += 1;\n    \n    rprintln!(\"üìä Reading #{}: {:.2}¬∞C, {:.1}%RH, {:.1}hPa\", \n             *reading_count, measurements.temperature, measurements.humidity, measurements.pressure);\n    \n    // Create sensor data structure\n    let sensor_data = SensorReading {\n        temperature: measurements.temperature,\n        humidity: measurements.humidity,\n        pressure: measurements.pressure,\n        timestamp: embassy_time::Instant::now().as_millis() as u64,\n        device_id: String::try_from(DEVICE_ID).unwrap_or_default(),\n    };\n    \n    // Serialize to JSON\n    let mut json_buffer = [0u8; 256];\n    let json_str = serde_json_core::to_slice(&sensor_data, &mut json_buffer)\n        .map_err(|_| IoTError::system(\n            iot_common::SystemError::SerializationError(\n                iot_common::error::utils::error_message(\"JSON serialization failed\")\n            )\n        ))\n        .with_context(\"JSON serialization\")?;\n    \n    // Publish to MQTT\n    let topic = \"esp32/sensor/bme280\";\n    mqtt_client.publish(topic, json_str).await\n        .map_err(|e| IoTError::network(\n            iot_common::NetworkError::TCPConnectionFailed(\n                iot_common::error::utils::error_message(&format!(\"MQTT publish failed: {}\", e))\n            )\n        ))\n        .with_context(\"MQTT publishing\")?;\n    \n    rprintln!(\"üì° Published to topic: {}\", topic);\n    \n    Ok(())\n}\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n    rprintln!(\"üí• PANIC: {}\", info);\n    loop {}\n}"