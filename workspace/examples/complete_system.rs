//! # Complete IoT System Integration Example
//! \n//! This example demonstrates the complete integration of all IoT modules:\n//! - BME280 environmental sensor\n//! - WiFi connectivity management\n//! - MQTT message publishing\n//! - Serial console interface\n//! - Unified error handling\n//!\n//! ## Hardware Requirements\n//!\n//! - ESP32-C3 DevKit board\n//! - BME280 sensor connected via I2C (GPIO8=SDA, GPIO9=SCL)\n//! - Status LED on GPIO3 (optional)\n//! - WiFi network (2.4GHz)\n//! - MQTT broker accessible on the network\n//!\n//! ## Configuration\n//!\n//! Set these environment variables in `.cargo/config.toml`:\n//!\n//! ```toml\n//! [env]\n//! WIFI_SSID = \"YourWiFiNetwork\"\n//! WIFI_PASSWORD = \"YourWiFiPassword\"\n//! MQTT_BROKER_IP = \"192.168.1.100\"\n//! MQTT_BROKER_PORT = \"1883\"\n//! DEVICE_ID = \"esp32c3_001\"\n//! ```\n//!\n//! ## Build and Run\n//!\n//! ```bash\n//! # From workspace root\n//! cargo build --example complete_system --release\n//! cargo run --example complete_system --release\n//! ```\n//!\n//! ## Expected Output\n//!\n//! The system will:\n//! 1. Initialize all hardware peripherals\n//! 2. Connect to WiFi network\n//! 3. Establish MQTT connection\n//! 4. Start periodic sensor readings\n//! 5. Publish sensor data to MQTT broker\n//! 6. Provide serial console interface\n//! 7. Handle errors gracefully with full context\n\n#![no_std]\n#![no_main]\n\n// Core Embassy and hardware\nuse embassy_executor::Spawner;\nuse embassy_time::{Duration, Timer};\nuse esp_hal::{\n    gpio::{Io, Level, Output},\n    i2c::I2c,\n    peripherals::Peripherals,\n    prelude::*,\n    system::SystemControl,\n};\nuse esp_hal_embassy;\n\n// IoT modules\nuse bme280_embassy::{BME280, Measurements};\nuse wifi_embassy::{WiFiManager, WiFiConfig};\nuse mqtt_embassy::{MqttClient, SensorData, DeviceStatus};\nuse serial_console_embassy::{SerialConsole, ConsoleCommand};\nuse iot_common::{IoTResult, IoTError, result::IoTResultExt};\n\n// Debugging and utilities\nuse rtt_target::{rprintln, rtt_init_print};\nuse embassy_sync::{\n    blocking_mutex::raw::ThreadModeRawMutex,\n    channel::Channel,\n    signal::Signal,\n};\nuse heapless::String;\nuse static_cell::StaticCell;\n\n// Configuration from environment\nconst WIFI_SSID: &str = env!(\"WIFI_SSID\", \"Configure WIFI_SSID in .cargo/config.toml\");\nconst WIFI_PASSWORD: &str = env!(\"WIFI_PASSWORD\", \"Configure WIFI_PASSWORD in .cargo/config.toml\");\nconst MQTT_BROKER_IP: &str = env!(\"MQTT_BROKER_IP\", \"Configure MQTT_BROKER_IP in .cargo/config.toml\");\nconst MQTT_BROKER_PORT: &str = env!(\"MQTT_BROKER_PORT\", \"1883\");\nconst DEVICE_ID: &str = env!(\"DEVICE_ID\", \"esp32c3_default\");\n\n// System timing configuration\nconst SENSOR_READING_INTERVAL: Duration = Duration::from_secs(30);\nconst HEARTBEAT_INTERVAL: Duration = Duration::from_secs(150); // 2.5 minutes\nconst STATUS_REPORT_INTERVAL: Duration = Duration::from_secs(300); // 5 minutes\n\n// Inter-task communication channels\nstatic SENSOR_DATA_CHANNEL: Channel<ThreadModeRawMutex, SensorData, 5> = Channel::new();\nstatic SYSTEM_STATUS_SIGNAL: Signal<ThreadModeRawMutex, DeviceStatus> = Signal::new();\nstatic CONSOLE_COMMAND_CHANNEL: Channel<ThreadModeRawMutex, ConsoleCommand, 3> = Channel::new();\n\n// Static allocations for Embassy tasks\nstatic WIFI_MANAGER: StaticCell<WiFiManager> = StaticCell::new();\nstatic MQTT_CLIENT: StaticCell<MqttClient> = StaticCell::new();\n\n/// Main application entry point\n#[esp_hal_embassy::main]\nasync fn main(spawner: Spawner) -> ! {\n    // Initialize RTT for debugging\n    rtt_init_print!();\n    rprintln!(\"üöÄ ESP32-C3 Complete IoT System Starting...\");\n    \n    // Initialize ESP32-C3 hardware\n    let peripherals = match init_hardware().with_context(\"Hardware initialization\") {\n        Ok(p) => p,\n        Err(e) => {\n            rprintln!(\"‚ùå Hardware initialization failed: {}\", e);\n            panic!(\"System cannot start without hardware\");\n        }\n    };\n    \n    rprintln!(\"‚úÖ Hardware initialized successfully\");\n    \n    // Initialize WiFi connectivity\n    let wifi_manager = match init_wifi_connectivity(spawner, peripherals.wifi_peripherals).await {\n        Ok(manager) => manager,\n        Err(e) => {\n            rprintln!(\"‚ùå WiFi initialization failed: {}\", e);\n            panic!(\"System requires WiFi connectivity\");\n        }\n    };\n    \n    rprintln!(\"‚úÖ WiFi connected successfully\");\n    \n    // Initialize MQTT client\n    let mqtt_client = match init_mqtt_client(wifi_manager.get_stack()).await {\n        Ok(client) => client,\n        Err(e) => {\n            rprintln!(\"‚ùå MQTT initialization failed: {}\", e);\n            panic!(\"System requires MQTT connectivity\");\n        }\n    };\n    \n    rprintln!(\"‚úÖ MQTT client initialized\");\n    \n    // Store in static cells for task access\n    let wifi_manager_ref = WIFI_MANAGER.init(wifi_manager);\n    let mqtt_client_ref = MQTT_CLIENT.init(mqtt_client);\n    \n    // Start system tasks\n    rprintln!(\"üéØ Starting system tasks...\");\n    \n    // Sensor reading task\n    spawner.spawn(sensor_task(peripherals.sensor_peripherals))\n        .map_err(|_| IoTError::system(iot_common::SystemError::TaskSpawnFailed(\n            iot_common::error::utils::error_message(\"Failed to spawn sensor task\")\n        )))\n        .with_context(\"Sensor task startup\")\n        .unwrap();\n    \n    // MQTT publishing task\n    spawner.spawn(mqtt_publisher_task(mqtt_client_ref))\n        .map_err(|_| IoTError::system(iot_common::SystemError::TaskSpawnFailed(\n            iot_common::error::utils::error_message(\"Failed to spawn MQTT task\")\n        )))\n        .with_context(\"MQTT task startup\")\n        .unwrap();\n    \n    // Status monitoring task\n    spawner.spawn(status_monitor_task(wifi_manager_ref, mqtt_client_ref))\n        .map_err(|_| IoTError::system(iot_common::SystemError::TaskSpawnFailed(\n            iot_common::error::utils::error_message(\"Failed to spawn status task\")\n        )))\n        .with_context(\"Status task startup\")\n        .unwrap();\n    \n    // Serial console task\n    spawner.spawn(console_task(peripherals.console_peripherals))\n        .map_err(|_| IoTError::system(iot_common::SystemError::TaskSpawnFailed(\n            iot_common::error::utils::error_message(\"Failed to spawn console task\")\n        )))\n        .with_context(\"Console task startup\")\n        .unwrap();\n    \n    // System health monitor task\n    spawner.spawn(health_monitor_task())\n        .map_err(|_| IoTError::system(iot_common::SystemError::TaskSpawnFailed(\n            iot_common::error::utils::error_message(\"Failed to spawn health monitor task\")\n        )))\n        .with_context(\"Health monitor startup\")\n        .unwrap();\n    \n    rprintln!(\"‚úÖ All tasks started successfully\");\n    rprintln!(\"üéâ IoT System is now operational!\");\n    rprintln!(\"üìä Publishing sensor data every {} seconds\", SENSOR_READING_INTERVAL.as_secs());\n    rprintln!(\"üíì Heartbeat every {} seconds\", HEARTBEAT_INTERVAL.as_secs());\n    rprintln!(\"üìà Status reports every {} seconds\", STATUS_REPORT_INTERVAL.as_secs());\n    \n    // Main loop - system coordination\n    main_system_loop().await\n}\n\n/// Hardware initialization structure\nstruct HardwarePeripherals {\n    sensor_peripherals: SensorPeripherals,\n    wifi_peripherals: WiFiPeripherals,\n    console_peripherals: ConsolePeripherals,\n    status_led: Output<'static>,\n}\n\nstruct SensorPeripherals {\n    i2c: I2c<'static, esp_hal::peripherals::I2C0>,\n}\n\nstruct WiFiPeripherals {\n    timg0: esp_hal::peripherals::TIMG0,\n    wifi: esp_hal::peripherals::WIFI,\n    rng: esp_hal::peripherals::RNG,\n}\n\nstruct ConsolePeripherals {\n    uart: esp_hal::uart::Uart<'static, esp_hal::peripherals::UART0>,\n}\n\n/// Initialize ESP32-C3 hardware peripherals\nfn init_hardware() -> IoTResult<HardwarePeripherals> {\n    rprintln!(\"üîß Initializing ESP32-C3 hardware...\");\n    \n    let peripherals = Peripherals::take();\n    let system = SystemControl::new(peripherals.SYSTEM);\n    let clocks = esp_hal::clock::ClockControl::max(system.clock_control).freeze();\n    \n    // Initialize Embassy time driver\n    esp_hal_embassy::init(peripherals.TIMG1);\n    \n    // Initialize GPIO\n    let io = Io::new(peripherals.GPIO, peripherals.IO_MUX);\n    \n    // Status LED (GPIO3)\n    let status_led = Output::new(io.pins.gpio3, Level::Low);\n    \n    // I2C for BME280 sensor (GPIO8=SDA, GPIO9=SCL)\n    let i2c_config = esp_hal::i2c::Config::default().frequency(100.kHz());\n    let i2c = I2c::new(\n        peripherals.I2C0,\n        io.pins.gpio8,  // SDA\n        io.pins.gpio9,  // SCL\n        i2c_config,\n        &clocks,\n    )\n    .map_err(|e| IoTError::hardware(\n        iot_common::HardwareError::GPIOError(\n            iot_common::error::utils::error_message(\"I2C initialization failed\")\n        )\n    ))\n    .with_context(\"I2C peripheral setup\")?;\n    \n    // UART for serial console (default pins)\n    let uart_config = esp_hal::uart::config::Config::default().baudrate(115200);\n    let uart = esp_hal::uart::Uart::new(\n        peripherals.UART0,\n        uart_config,\n        &clocks,\n    )\n    .map_err(|_| IoTError::hardware(\n        iot_common::HardwareError::UARTError(\n            iot_common::error::utils::error_message(\"UART initialization failed\")\n        )\n    ))\n    .with_context(\"UART peripheral setup\")?;\n    \n    Ok(HardwarePeripherals {\n        sensor_peripherals: SensorPeripherals { i2c },\n        wifi_peripherals: WiFiPeripherals {\n            timg0: peripherals.TIMG0,\n            wifi: peripherals.WIFI,\n            rng: peripherals.RNG,\n        },\n        console_peripherals: ConsolePeripherals { uart },\n        status_led,\n    })\n}\n\n/// Initialize WiFi connectivity\nasync fn init_wifi_connectivity(\n    spawner: Spawner,\n    wifi_peripherals: WiFiPeripherals,\n) -> IoTResult<WiFiManager> {\n    rprintln!(\"üì° Initializing WiFi connectivity...\");\n    rprintln!(\"   Target SSID: {}\", WIFI_SSID);\n    \n    let wifi_config = WiFiConfig {\n        ssid: WIFI_SSID,\n        password: WIFI_PASSWORD,\n    };\n    \n    let wifi_manager = WiFiManager::new(\n        spawner,\n        wifi_peripherals.timg0,\n        wifi_peripherals.wifi,\n        wifi_peripherals.rng,\n        wifi_config,\n    )\n    .await\n    .map_err(|e| IoTError::network(\n        iot_common::NetworkError::WiFiConnectionFailed(\n            iot_common::error::utils::error_message(&format!(\"WiFi init failed: {}\", e))\n        )\n    ))\n    .with_context(\"WiFi manager initialization\")?;\n    \n    // Display connection information\n    if let Some(conn_info) = wifi_manager.get_connection_info() {\n        rprintln!(\"   üìç IP Address: {}\", conn_info.ip_address);\n        rprintln!(\"   üåê Gateway: {:?}\", conn_info.gateway);\n        rprintln!(\"   üîß Subnet: /{}\", conn_info.subnet_prefix);\n    }\n    \n    Ok(wifi_manager)\n}\n\n/// Initialize MQTT client\nasync fn init_mqtt_client(stack: &'static embassy_net::Stack<esp_wifi::wifi::WifiDevice>) -> IoTResult<MqttClient> {\n    rprintln!(\"üì® Initializing MQTT client...\");\n    rprintln!(\"   Broker: {}:{}\", MQTT_BROKER_IP, MQTT_BROKER_PORT);\n    \n    let broker_port: u16 = MQTT_BROKER_PORT.parse()\n        .map_err(|_| IoTError::configuration(\n            iot_common::ConfigError::InvalidParameter(\n                iot_common::error::utils::error_message(\"Invalid MQTT port number\")\n            )\n        ))\n        .with_context(\"MQTT port parsing\")?;\n    \n    let mqtt_config = mqtt_embassy::MqttConfig {\n        broker_ip: MQTT_BROKER_IP,\n        broker_port,\n        client_id: DEVICE_ID,\n        username: None,\n        password: None,\n    };\n    \n    let mqtt_client = MqttClient::new(stack, mqtt_config)\n        .await\n        .map_err(|e| IoTError::network(\n            iot_common::NetworkError::TCPConnectionFailed(\n                iot_common::error::utils::error_message(&format!(\"MQTT init failed: {}\", e))\n            )\n        ))\n        .with_context(\"MQTT client initialization\")?;\n    \n    Ok(mqtt_client)\n}\n\n/// Sensor reading task\n#[embassy_executor::task]\nasync fn sensor_task(sensor_peripherals: SensorPeripherals) {\n    rprintln!(\"üå°Ô∏è Starting sensor task...\");\n    \n    let mut sensor = BME280::new(&mut sensor_peripherals.i2c);\n    let mut reading_count: u32 = 0;\n    \n    // Initialize sensor\n    match sensor.init().await {\n        Ok(()) => rprintln!(\"   BME280 sensor initialized successfully\"),\n        Err(e) => {\n            rprintln!(\"‚ùå BME280 initialization failed: {:?}\", e);\n            return;\n        }\n    }\n    \n    loop {\n        match sensor.read_measurements().await {\n            Ok(measurements) => {\n                reading_count += 1;\n                \n                rprintln!(\"üìä Sensor Reading #{}: T={:.2}¬∞C, H={:.2}%RH, P={:.2}hPa\", \n                         reading_count, measurements.temperature, measurements.humidity, measurements.pressure);\n                \n                let sensor_data = SensorData {\n                    device_id: String::try_from(DEVICE_ID).unwrap_or_default(),\n                    timestamp: embassy_time::Instant::now().as_millis() as u64,\n                    temperature: measurements.temperature,\n                    humidity: measurements.humidity,\n                    pressure: measurements.pressure,\n                    reading_id: reading_count,\n                };\n                \n                // Send to MQTT publisher\n                if SENSOR_DATA_CHANNEL.try_send(sensor_data).is_err() {\n                    rprintln!(\"‚ö†Ô∏è Sensor data channel full, dropping reading\");\n                }\n            }\n            Err(e) => {\n                rprintln!(\"‚ùå Sensor reading failed: {:?}\", e);\n            }\n        }\n        \n        Timer::after(SENSOR_READING_INTERVAL).await;\n    }\n}\n\n/// MQTT publishing task\n#[embassy_executor::task]\nasync fn mqtt_publisher_task(mqtt_client: &'static MqttClient) {\n    rprintln!(\"üì§ Starting MQTT publisher task...\");\n    \n    let mut heartbeat_counter = 0u32;\n    let heartbeat_period = (HEARTBEAT_INTERVAL.as_secs() / SENSOR_READING_INTERVAL.as_secs()) as u32;\n    \n    loop {\n        // Check for sensor data to publish\n        if let Ok(sensor_data) = SENSOR_DATA_CHANNEL.try_receive() {\n            let topic = format!(\"esp32/{}/sensor/bme280\", DEVICE_ID);\n            \n            match mqtt_client.publish_sensor_data(&topic, &sensor_data).await {\n                Ok(()) => {\n                    rprintln!(\"üì° Published sensor data to {}\", topic);\n                }\n                Err(e) => {\n                    rprintln!(\"‚ùå MQTT publish failed: {}\", e);\n                }\n            }\n        }\n        \n        // Periodic heartbeat\n        heartbeat_counter += 1;\n        if heartbeat_counter >= heartbeat_period {\n            heartbeat_counter = 0;\n            \n            let heartbeat_topic = format!(\"esp32/{}/heartbeat\", DEVICE_ID);\n            let heartbeat_payload = \"alive\";\n            \n            match mqtt_client.publish(&heartbeat_topic, heartbeat_payload.as_bytes()).await {\n                Ok(()) => {\n                    rprintln!(\"üíì Heartbeat sent\");\n                }\n                Err(e) => {\n                    rprintln!(\"‚ùå Heartbeat failed: {}\", e);\n                }\n            }\n        }\n        \n        Timer::after(Duration::from_secs(1)).await;\n    }\n}\n\n/// System status monitoring task\n#[embassy_executor::task]\nasync fn status_monitor_task(\n    wifi_manager: &'static WiFiManager,\n    mqtt_client: &'static MqttClient,\n) {\n    rprintln!(\"üìà Starting status monitor task...\");\n    \n    loop {\n        let status = DeviceStatus {\n            device_id: String::try_from(DEVICE_ID).unwrap_or_default(),\n            timestamp: embassy_time::Instant::now().as_millis() as u64,\n            status: \"operational\".into(),\n            uptime_seconds: embassy_time::Instant::now().as_secs(),\n            free_heap_bytes: get_free_heap_size(),\n            wifi_connected: wifi_manager.is_connected(),\n            ip_address: wifi_manager.get_connection_info()\n                .map(|info| format!(\"{}\", info.ip_address))\n                .unwrap_or_default(),\n        };\n        \n        let status_topic = format!(\"esp32/{}/status\", DEVICE_ID);\n        \n        match mqtt_client.publish_device_status(&status_topic, &status).await {\n            Ok(()) => {\n                rprintln!(\"üìä Status report published - Uptime: {}s, Heap: {}KB\", \n                         status.uptime_seconds, status.free_heap_bytes / 1024);\n            }\n            Err(e) => {\n                rprintln!(\"‚ùå Status publish failed: {}\", e);\n            }\n        }\n        \n        // Signal status to other tasks if needed\n        SYSTEM_STATUS_SIGNAL.signal(status);\n        \n        Timer::after(STATUS_REPORT_INTERVAL).await;\n    }\n}\n\n/// Serial console interface task\n#[embassy_executor::task]\nasync fn console_task(console_peripherals: ConsolePeripherals) {\n    rprintln!(\"üñ•Ô∏è Starting serial console task...\");\n    \n    let console = SerialConsole::new(console_peripherals.uart);\n    \n    loop {\n        match console.read_command().await {\n            Ok(command) => {\n                rprintln!(\"üìù Console command received: {:?}\", command);\n                \n                // Send command to processing channel\n                if CONSOLE_COMMAND_CHANNEL.try_send(command).is_err() {\n                    rprintln!(\"‚ö†Ô∏è Console command channel full\");\n                }\n            }\n            Err(e) => {\n                rprintln!(\"‚ùå Console read error: {}\", e);\n            }\n        }\n        \n        Timer::after(Duration::from_millis(100)).await;\n    }\n}\n\n/// System health monitoring task\n#[embassy_executor::task]\nasync fn health_monitor_task() {\n    rprintln!(\"üè• Starting health monitor task...\");\n    \n    let mut last_sensor_data = embassy_time::Instant::now();\n    let mut last_status_report = embassy_time::Instant::now();\n    \n    loop {\n        let now = embassy_time::Instant::now();\n        \n        // Check for sensor data timeout\n        if now.duration_since(last_sensor_data) > Duration::from_secs(60) {\n            rprintln!(\"‚ö†Ô∏è WARNING: No sensor data received in 60 seconds\");\n        }\n        \n        // Check for status report timeout\n        if now.duration_since(last_status_report) > Duration::from_secs(400) {\n            rprintln!(\"‚ö†Ô∏è WARNING: No status reports in 400 seconds\");\n        }\n        \n        // Check heap memory\n        let free_heap = get_free_heap_size();\n        if free_heap < 10000 {\n            rprintln!(\"üö® CRITICAL: Low memory - only {}KB free\", free_heap / 1024);\n        }\n        \n        // Update last activity timestamps\n        if SENSOR_DATA_CHANNEL.len() > 0 {\n            last_sensor_data = now;\n        }\n        \n        if let Ok(_) = SYSTEM_STATUS_SIGNAL.try_take() {\n            last_status_report = now;\n        }\n        \n        Timer::after(Duration::from_secs(30)).await;\n    }\n}\n\n/// Main system coordination loop\nasync fn main_system_loop() -> ! {\n    let mut status_led_state = false;\n    \n    loop {\n        // Process console commands\n        if let Ok(command) = CONSOLE_COMMAND_CHANNEL.try_receive() {\n            handle_console_command(command).await;\n        }\n        \n        // Toggle status LED to show system is alive\n        status_led_state = !status_led_state;\n        // Note: In a real implementation, you'd access the LED through a shared resource\n        \n        Timer::after(Duration::from_secs(5)).await;\n    }\n}\n\n/// Handle console commands\nasync fn handle_console_command(command: ConsoleCommand) {\n    match command {\n        ConsoleCommand::Status => {\n            rprintln!(\"üìä System Status:\");\n            rprintln!(\"   Device ID: {}\", DEVICE_ID);\n            rprintln!(\"   Uptime: {}s\", embassy_time::Instant::now().as_secs());\n            rprintln!(\"   Free heap: {}KB\", get_free_heap_size() / 1024);\n            rprintln!(\"   Sensor readings: {} in queue\", SENSOR_DATA_CHANNEL.len());\n        }\n        ConsoleCommand::Reset => {\n            rprintln!(\"üîÑ System reset requested via console\");\n            esp_hal::reset::software_reset();\n        }\n        ConsoleCommand::Help => {\n            rprintln!(\"üìñ Available commands:\");\n            rprintln!(\"   status - Show system status\");\n            rprintln!(\"   reset  - Restart the system\");\n            rprintln!(\"   help   - Show this help\");\n        }\n        _ => {\n            rprintln!(\"‚ùì Unknown console command: {:?}\", command);\n        }\n    }\n}\n\n/// Get free heap size (placeholder implementation)\nfn get_free_heap_size() -> u32 {\n    // In a real implementation, this would query the heap allocator\n    // For now, return a simulated value\n    45000 - (embassy_time::Instant::now().as_secs() as u32 * 10)\n}\n\n/// Panic handler for no_std environment\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n    rprintln!(\"üí• PANIC: {}\", info);\n    \n    loop {\n        // Infinite loop on panic\n    }\n}"