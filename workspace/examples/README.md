# Integration Examples\n\n> Comprehensive examples demonstrating ESP32-C3 IoT system integration patterns\n\nThis directory contains practical examples showing how to integrate and use the ESP32-C3 IoT system modules together. Each example focuses on different aspects of the system and demonstrates best practices for real-world applications.\n\n## Available Examples\n\n### 1. Complete System Integration (`complete_system.rs`)\n\n**Purpose**: Demonstrates the full IoT system with all modules working together\n\n**Features**:\n- Complete hardware initialization\n- Multi-task Embassy coordination\n- Sensor reading and MQTT publishing\n- Serial console interface\n- System health monitoring\n- Comprehensive error handling\n- Inter-task communication patterns\n\n**Hardware Requirements**:\n- ESP32-C3 DevKit\n- BME280 sensor (I2C)\n- WiFi network access\n- MQTT broker\n\n**Use Case**: Production-ready IoT application template\n\n```bash\n# Build and run\ncargo build --example complete_system --release\ncargo run --example complete_system --release\n```\n\n### 2. Sensor to MQTT (`sensor_to_mqtt.rs`)\n\n**Purpose**: Simplified sensor-to-cloud data pipeline\n\n**Features**:\n- BME280 sensor reading\n- WiFi connectivity\n- MQTT message publishing\n- JSON data serialization\n- Basic error handling\n\n**Hardware Requirements**:\n- ESP32-C3 DevKit\n- BME280 sensor\n- WiFi network\n- MQTT broker\n\n**Use Case**: Basic IoT sensor node implementation\n\n```bash\n# Build and run\ncargo build --example sensor_to_mqtt --release\ncargo run --example sensor_to_mqtt --release\n```\n\n### 3. Error Handling Demo (`error_handling_demo.rs`)\n\n**Purpose**: Comprehensive demonstration of unified error handling\n\n**Features**:\n- All error categories (Sensor, Network, Hardware, Config, System)\n- Error context preservation\n- Recovery strategies (retry, degradation, circuit breaker)\n- Error monitoring and statistics\n- Graceful failure handling\n\n**Hardware Requirements**:\n- ESP32-C3 DevKit (minimal setup)\n- Optional: BME280 for real sensor errors\n\n**Use Case**: Understanding and testing error handling patterns\n\n```bash\n# Build and run\ncargo build --example error_handling_demo --release\ncargo run --example error_handling_demo --release\n```\n\n## Configuration\n\n### Environment Variables\n\nAll examples use environment variables for configuration. Create `.cargo/config.toml` in each example directory or use the workspace-level configuration:\n\n```toml\n# .cargo/config.toml\n[env]\nWIFI_SSID = \"YourWiFiNetwork\"\nWIFI_PASSWORD = \"YourWiFiPassword\"\nMQTT_BROKER_IP = \"192.168.1.100\"\nMQTT_BROKER_PORT = \"1883\"\nDEVICE_ID = \"esp32c3_001\"\n```\n\n### Hardware Connections\n\nStandard hardware setup for all examples:\n\n| Component | ESP32-C3 Pin | Notes |\n|-----------|--------------|-------|\n| BME280 VCC | 3.3V | Power supply |\n| BME280 GND | GND | Ground |\n| BME280 SDA | GPIO8 | I2C data line |\n| BME280 SCL | GPIO9 | I2C clock line |\n| Status LED | GPIO3 | Optional status indicator |\n\n**Important**: Add 4.7kŒ© pull-up resistors on SDA and SCL lines.\n\n## Building Examples\n\n### From Workspace Root\n\n```bash\n# Build all examples\ncargo build --examples --release\n\n# Build specific example\ncargo build --example complete_system --release\n\n# Run specific example\ncargo run --example sensor_to_mqtt --release\n```\n\n### Individual Example Build\n\n```bash\n# Navigate to workspace\ncd workspace/\n\n# Check example syntax\ncargo check --example error_handling_demo\n\n# Build with debug info\ncargo build --example complete_system\n\n# Run with debugging\ncargo run --example complete_system\n```\n\n## Expected Output\n\n### Complete System Example\n\n```\nüöÄ ESP32-C3 Complete IoT System Starting...\n‚úÖ Hardware initialized successfully\nüì° WiFi connecting to 'YourNetwork'...\n‚úÖ WiFi connected: IP=192.168.1.214\nüì® MQTT connecting to broker at 192.168.1.100:1883\n‚úÖ MQTT client initialized\nüéØ Starting system tasks...\nüå°Ô∏è Starting sensor task...\nüì§ Starting MQTT publisher task...\nüìà Starting status monitor task...\nüñ•Ô∏è Starting serial console task...\nüè• Starting health monitor task...\n‚úÖ All tasks started successfully\nüéâ IoT System is now operational!\nüìä Sensor Reading #1: T=23.2¬∞C, H=68.5%RH, P=1013.8hPa\nüì° Published sensor data to esp32/esp32c3_001/sensor/bme280\nüíì Heartbeat sent\n```\n\n### Error Handling Demo\n\n```\nüöÄ Error Handling Demo Starting...\nüß™ === ERROR SCENARIO DEMONSTRATIONS ===\n\n1Ô∏è‚É£ Testing Hardware Initialization Errors\n   ‚úÖ Hardware initialized successfully\n\n2Ô∏è‚É£ Testing Sensor Communication Errors\n   ‚ùå Sensor operation failed:\n      Error: BME280 sensor not detected on I2C bus [Context: Environmental monitoring subsystem <- Sensor presence verification]\n      Category: Sensor\n      Error Code: 1005\n      üå°Ô∏è Sensor error detected - implementing sensor recovery\n\nüìä === ERROR STATISTICS ===\n   Total errors encountered: 3\n   üå°Ô∏è Sensor errors: 1\n   üì° Network errors: 2\n   üîÑ Recovery attempts: 1\n   ‚úÖ Successful recoveries: 1\n   üìà Recovery success rate: 100%\n```\n\n## Development Patterns\n\n### Embassy Task Structure\n\nAll examples follow consistent Embassy async patterns:\n\n```rust\n#[embassy_executor::task]\nasync fn sensor_task(peripherals: SensorPeripherals) {\n    // Task initialization\n    let mut sensor = BME280::new(peripherals.i2c);\n    sensor.init().await.unwrap();\n    \n    // Main task loop\n    loop {\n        // Async operations\n        let data = sensor.read_measurements().await?;\n        \n        // Inter-task communication\n        SENSOR_CHANNEL.send(data).await;\n        \n        // Timing control\n        Timer::after(Duration::from_secs(30)).await;\n    }\n}\n```\n\n### Error Handling Patterns\n\nConsistent error handling using iot-common:\n\n```rust\nuse iot_common::{IoTResult, IoTError, result::IoTResultExt};\n\nasync fn sensor_operation() -> IoTResult<Measurements> {\n    let measurements = sensor.read_measurements().await\n        .map_err(|e| IoTError::sensor(\n            SensorError::I2CError(\n                error_message(\"Sensor communication failed\")\n            )\n        ))\n        .with_context(\"Environmental data collection\")?;\n    \n    Ok(measurements)\n}\n```\n\n### Configuration Management\n\nEnvironment-based configuration:\n\n```rust\n// Load from environment variables\nconst WIFI_SSID: &str = env!(\"WIFI_SSID\", \"Configure in .cargo/config.toml\");\nconst MQTT_BROKER: &str = env!(\"MQTT_BROKER_IP\", \"192.168.1.100\");\n\n// Validate configuration\nfn validate_config() -> IoTResult<()> {\n    if WIFI_SSID.is_empty() {\n        return Err(IoTError::configuration(\n            ConfigError::MissingParameter(\n                error_message(\"WiFi SSID not configured\")\n            )\n        ));\n    }\n    Ok(())\n}\n```\n\n### Inter-task Communication\n\nUsing Embassy channels and signals:\n\n```rust\nuse embassy_sync::{\n    channel::Channel,\n    signal::Signal,\n    blocking_mutex::raw::ThreadModeRawMutex,\n};\n\n// Channels for data flow\nstatic SENSOR_DATA: Channel<ThreadModeRawMutex, SensorData, 10> = Channel::new();\n\n// Signals for events\nstatic SYSTEM_STATUS: Signal<ThreadModeRawMutex, Status> = Signal::new();\n\n// Usage in tasks\n#[embassy_executor::task]\nasync fn producer_task() {\n    loop {\n        let data = collect_data().await;\n        SENSOR_DATA.send(data).await;\n    }\n}\n\n#[embassy_executor::task]\nasync fn consumer_task() {\n    loop {\n        let data = SENSOR_DATA.receive().await;\n        process_data(data).await;\n    }\n}\n```\n\n## Troubleshooting Examples\n\n### Common Build Issues\n\n1. **Missing Target**:\n   ```bash\n   rustup target add riscv32imc-unknown-none-elf\n   ```\n\n2. **Environment Variables**:\n   ```bash\n   # Check configuration\n   echo $WIFI_SSID\n   \n   # Set temporarily\n   export WIFI_SSID=\"MyNetwork\"\n   ```\n\n3. **Memory Issues**:\n   ```bash\n   # Use release mode\n   cargo build --example complete_system --release\n   ```\n\n### Runtime Issues\n\n1. **WiFi Connection**:\n   - Verify 2.4GHz network\n   - Check SSID and password spelling\n   - Ensure network allows new devices\n\n2. **MQTT Connection**:\n   - Test broker connectivity: `telnet <broker_ip> 1883`\n   - Check firewall settings\n   - Verify broker is running\n\n3. **Sensor Issues**:\n   - Check I2C wiring and pull-up resistors\n   - Verify sensor power supply (3.3V)\n   - Test with `i2cdetect` if available\n\n### Debug Output\n\nAll examples include comprehensive RTT debugging:\n\n```bash\n# Monitor output during execution\ncargo run --example complete_system --release\n\n# Output includes:\n# - System initialization progress\n# - Error messages with context\n# - Performance metrics\n# - System health information\n```\n\n## Extension Ideas\n\n### Additional Examples to Consider\n\n1. **Power Management**: Deep sleep and battery optimization\n2. **Security**: TLS/SSL MQTT connections and certificate management\n3. **OTA Updates**: Over-the-air firmware update implementation\n4. **Multi-sensor**: Integration with multiple sensor types\n5. **Edge Processing**: Local data processing and filtering\n6. **Monitoring**: System telemetry and performance monitoring\n\n### Custom Adaptations\n\n- **Different Sensors**: Adapt for other I2C/SPI sensors\n- **Alternative Protocols**: LoRaWAN, Bluetooth, or other connectivity\n- **Cloud Integration**: AWS IoT, Azure IoT, or Google Cloud IoT\n- **Data Processing**: Edge computing and local analytics\n- **User Interface**: Web dashboard or mobile app integration\n\nThese examples provide a solid foundation for building production IoT applications with the ESP32-C3 platform, demonstrating best practices for embedded Rust development with Embassy async framework."