//! # Error Handling Integration Demo\n//!\n//! This example demonstrates the unified error handling system throughout\n//! the IoT stack, showing how errors are propagated, contextualized, and\n//! handled gracefully across all modules.\n//!\n//! ## Features Demonstrated\n//!\n//! - Unified error types from iot-common\n//! - Error context preservation through call chains\n//! - Graceful error recovery strategies\n//! - Error logging and monitoring\n//! - Different error categories and their handling\n//!\n//! ## Error Categories Shown\n//!\n//! - **Sensor Errors**: I2C communication, invalid data, calibration\n//! - **Network Errors**: WiFi connection, MQTT broker, timeouts\n//! - **Hardware Errors**: GPIO, peripheral initialization\n//! - **Configuration Errors**: Invalid parameters, missing settings\n//! - **System Errors**: Memory, task spawning, serialization\n//!\n//! ## Expected Behavior\n//!\n//! The system will:\n//! 1. Attempt to initialize all components\n//! 2. Handle various error conditions gracefully\n//! 3. Show detailed error context and recovery attempts\n//! 4. Continue operation where possible\n//! 5. Demonstrate error monitoring and reporting\n\n#![no_std]\n#![no_main]\n\nuse embassy_executor::Spawner;\nuse embassy_time::{Duration, Timer};\nuse esp_hal::{\n    gpio::Io,\n    i2c::I2c,\n    peripherals::Peripherals,\n    prelude::*,\n    system::SystemControl,\n};\nuse esp_hal_embassy;\n\n// IoT modules and error handling\nuse bme280_embassy::BME280;\nuse wifi_embassy::{WiFiManager, WiFiConfig, WiFiError};\nuse mqtt_embassy::{MqttClient, MqttError};\nuse iot_common::{\n    IoTResult, IoTError, IoTErrorKind,\n    SensorError, NetworkError, HardwareError, ConfigError, SystemError,\n    result::IoTResultExt,\n    error::utils,\n};\n\n// Utilities\nuse rtt_target::{rprintln, rtt_init_print};\nuse heapless::String;\n\n// Configuration with intentional error scenarios\nconst WIFI_SSID: &str = env!(\"WIFI_SSID\", \"DEMO_NETWORK\");  // May not exist\nconst WIFI_PASSWORD: &str = env!(\"WIFI_PASSWORD\", \"wrong_password\");\nconst MQTT_BROKER: &str = env!(\"MQTT_BROKER\", \"192.168.1.999\");  // Invalid IP\nconst DEVICE_ID: &str = \"error_demo_device\";\n\n/// Error statistics for monitoring\n#[derive(Default)]\nstruct ErrorStats {\n    sensor_errors: u32,\n    network_errors: u32,\n    hardware_errors: u32,\n    config_errors: u32,\n    system_errors: u32,\n    total_errors: u32,\n    recovery_attempts: u32,\n    successful_recoveries: u32,\n}\n\n#[esp_hal_embassy::main]\nasync fn main(spawner: Spawner) -> ! {\n    rtt_init_print!();\n    rprintln!(\"🚀 Error Handling Demo Starting...\");\n    rprintln!(\"📖 This demo shows comprehensive error handling across all IoT modules\");\n    \n    let mut error_stats = ErrorStats::default();\n    \n    // Main error handling demonstration loop\n    loop {\n        rprintln!(\"\\n🔄 Starting new error handling cycle...\");\n        \n        // Demonstrate different error scenarios\n        demonstrate_error_scenarios(spawner, &mut error_stats).await;\n        \n        // Show error statistics\n        display_error_statistics(&error_stats);\n        \n        rprintln!(\"⏱️ Waiting 30 seconds before next cycle...\");\n        Timer::after(Duration::from_secs(30)).await;\n    }\n}\n\n/// Demonstrate various error scenarios and handling\nasync fn demonstrate_error_scenarios(spawner: Spawner, stats: &mut ErrorStats) {\n    rprintln!(\"\\n🧪 === ERROR SCENARIO DEMONSTRATIONS ===\");\n    \n    // 1. Hardware initialization errors\n    rprintln!(\"\\n1️⃣ Testing Hardware Initialization Errors\");\n    match demonstrate_hardware_errors().await {\n        Ok(()) => rprintln!(\"   ✅ Hardware initialized successfully\"),\n        Err(e) => {\n            stats.hardware_errors += 1;\n            stats.total_errors += 1;\n            handle_error_with_context(&e, \"Hardware initialization\", stats);\n        }\n    }\n    \n    // 2. Sensor communication errors\n    rprintln!(\"\\n2️⃣ Testing Sensor Communication Errors\");\n    match demonstrate_sensor_errors().await {\n        Ok(measurements) => {\n            rprintln!(\"   ✅ Sensor reading successful: {:.2}°C, {:.1}%RH, {:.1}hPa\", \n                     measurements.temperature, measurements.humidity, measurements.pressure);\n        }\n        Err(e) => {\n            stats.sensor_errors += 1;\n            stats.total_errors += 1;\n            handle_error_with_context(&e, \"Sensor operation\", stats);\n        }\n    }\n    \n    // 3. Network connectivity errors\n    rprintln!(\"\\n3️⃣ Testing Network Connectivity Errors\");\n    match demonstrate_network_errors(spawner).await {\n        Ok(_) => rprintln!(\"   ✅ Network connectivity successful\"),\n        Err(e) => {\n            stats.network_errors += 1;\n            stats.total_errors += 1;\n            handle_error_with_context(&e, \"Network connectivity\", stats);\n        }\n    }\n    \n    // 4. Configuration errors\n    rprintln!(\"\\n4️⃣ Testing Configuration Errors\");\n    match demonstrate_config_errors().await {\n        Ok(()) => rprintln!(\"   ✅ Configuration validation successful\"),\n        Err(e) => {\n            stats.config_errors += 1;\n            stats.total_errors += 1;\n            handle_error_with_context(&e, \"Configuration validation\", stats);\n        }\n    }\n    \n    // 5. System errors\n    rprintln!(\"\\n5️⃣ Testing System Errors\");\n    match demonstrate_system_errors().await {\n        Ok(()) => rprintln!(\"   ✅ System operations successful\"),\n        Err(e) => {\n            stats.system_errors += 1;\n            stats.total_errors += 1;\n            handle_error_with_context(&e, \"System operation\", stats);\n        }\n    }\n    \n    // 6. Error recovery demonstration\n    rprintln!(\"\\n6️⃣ Testing Error Recovery\");\n    demonstrate_error_recovery(stats).await;\n}\n\n/// Demonstrate hardware-related errors\nasync fn demonstrate_hardware_errors() -> IoTResult<()> {\n    rprintln!(\"   🔧 Attempting hardware initialization...\");\n    \n    let peripherals = Peripherals::take();\n    let system = SystemControl::new(peripherals.SYSTEM);\n    let clocks = esp_hal::clock::ClockControl::max(system.clock_control).freeze();\n    \n    // Initialize Embassy\n    esp_hal_embassy::init(peripherals.TIMG1);\n    \n    // Try to initialize I2C with potentially problematic configuration\n    let io = Io::new(peripherals.GPIO, peripherals.IO_MUX);\n    \n    // Simulate potential I2C initialization failure\n    let i2c_config = esp_hal::i2c::Config::default().frequency(100.kHz());\n    let _i2c = I2c::new(\n        peripherals.I2C0,\n        io.pins.gpio8,  // SDA\n        io.pins.gpio9,  // SCL\n        i2c_config,\n        &clocks,\n    )\n    .map_err(|_| IoTError::hardware(\n        HardwareError::GPIOError(\n            utils::error_message(\"Failed to configure I2C pins\")\n        )\n    ))\n    .with_context(\"I2C peripheral configuration\")\n    .with_context(\"Hardware subsystem initialization\")?;\n    \n    rprintln!(\"   ✅ I2C hardware configured successfully\");\n    Ok(())\n}\n\n/// Demonstrate sensor-related errors\nasync fn demonstrate_sensor_errors() -> IoTResult<bme280_embassy::Measurements> {\n    rprintln!(\"   🌡️ Attempting sensor operations...\");\n    \n    // This will likely fail if no BME280 is connected\n    // but demonstrates proper error handling\n    \n    // Simulate sensor initialization\n    rprintln!(\"   📡 Checking sensor presence...\");\n    \n    // For demo purposes, we'll simulate different sensor error conditions\n    let sensor_present = check_sensor_mock_implementation().await;\n    \n    if !sensor_present {\n        return Err(IoTError::sensor(\n            SensorError::NotResponding(\n                utils::error_message(\"BME280 sensor not detected on I2C bus\")\n            )\n        )\n        .with_context(\"Sensor presence verification\")\n        .with_context(\"Environmental monitoring subsystem\"));\n    }\n    \n    // Simulate successful reading\n    rprintln!(\"   📊 Reading sensor measurements...\");\n    \n    // Mock measurements (in real scenario, this would be actual sensor readings)\n    let measurements = bme280_embassy::Measurements {\n        temperature: 23.5,\n        humidity: 65.2,\n        pressure: 1013.8,\n    };\n    \n    Ok(measurements)\n}\n\n/// Mock sensor check (replace with actual sensor.check_id() in real implementation)\nasync fn check_sensor_mock_implementation() -> bool {\n    // Simulate I2C communication delay\n    Timer::after(Duration::from_millis(100)).await;\n    \n    // Return false to demonstrate error handling\n    // In real implementation: sensor.check_id().await.unwrap_or(false)\n    false\n}\n\n/// Demonstrate network-related errors\nasync fn demonstrate_network_errors(spawner: Spawner) -> IoTResult<()> {\n    rprintln!(\"   📡 Attempting network operations...\");\n    \n    // Try WiFi connection with potentially invalid credentials\n    let wifi_config = WiFiConfig {\n        ssid: WIFI_SSID,\n        password: WIFI_PASSWORD,\n    };\n    \n    rprintln!(\"   🔗 Attempting WiFi connection to: {}\", WIFI_SSID);\n    \n    // This will likely fail with demo credentials\n    match attempt_wifi_connection_simulation(&wifi_config).await {\n        Ok(()) => {\n            rprintln!(\"   ✅ WiFi connected successfully\");\n            \n            // Try MQTT connection\n            rprintln!(\"   📨 Attempting MQTT connection to: {}\", MQTT_BROKER);\n            \n            match attempt_mqtt_connection_simulation().await {\n                Ok(()) => rprintln!(\"   ✅ MQTT connected successfully\"),\n                Err(e) => {\n                    return Err(e.with_context(\"MQTT broker connection\")\n                               .with_context(\"Messaging subsystem initialization\"));\n                }\n            }\n        }\n        Err(e) => {\n            return Err(e.with_context(\"WiFi network connection\")\n                       .with_context(\"Network subsystem initialization\"));\n        }\n    }\n    \n    Ok(())\n}\n\n/// Simulate WiFi connection attempt\nasync fn attempt_wifi_connection_simulation(config: &WiFiConfig) -> IoTResult<()> {\n    // Simulate connection delay\n    Timer::after(Duration::from_millis(500)).await;\n    \n    // Check for obvious configuration issues\n    if config.ssid == \"DEMO_NETWORK\" {\n        return Err(IoTError::network(\n            NetworkError::WiFiConnectionFailed(\n                utils::error_message(\"Demo network does not exist\")\n            )\n        ));\n    }\n    \n    if config.password == \"wrong_password\" {\n        return Err(IoTError::network(\n            NetworkError::WiFiConnectionFailed(\n                utils::error_message(\"Authentication failed - invalid password\")\n            )\n        ));\n    }\n    \n    // In a real implementation, this would attempt actual WiFi connection\n    Ok(())\n}\n\n/// Simulate MQTT connection attempt\nasync fn attempt_mqtt_connection_simulation() -> IoTResult<()> {\n    // Simulate connection delay\n    Timer::after(Duration::from_millis(300)).await;\n    \n    // Check for invalid broker IP\n    if MQTT_BROKER == \"192.168.1.999\" {\n        return Err(IoTError::network(\n            NetworkError::TCPConnectionFailed(\n                utils::error_message(\"MQTT broker IP address unreachable\")\n            )\n        ));\n    }\n    \n    Ok(())\n}\n\n/// Demonstrate configuration-related errors\nasync fn demonstrate_config_errors() -> IoTResult<()> {\n    rprintln!(\"   ⚙️ Validating system configuration...\");\n    \n    // Validate WiFi SSID length\n    if WIFI_SSID.len() > 32 {\n        return Err(IoTError::configuration(\n            ConfigError::InvalidParameter(\n                utils::error_message(\"WiFi SSID exceeds maximum length of 32 characters\")\n            )\n        )\n        .with_context(\"WiFi SSID validation\")\n        .with_context(\"Network configuration validation\"));\n    }\n    \n    // Validate WiFi password length\n    if WIFI_PASSWORD.len() < 8 {\n        return Err(IoTError::configuration(\n            ConfigError::InvalidParameter(\n                utils::error_message(\"WiFi password must be at least 8 characters\")\n            )\n        )\n        .with_context(\"WiFi password validation\")\n        .with_context(\"Security configuration validation\"));\n    }\n    \n    // Validate MQTT broker IP format\n    if !is_valid_ip_format(MQTT_BROKER) {\n        return Err(IoTError::configuration(\n            ConfigError::InvalidParameter(\n                utils::error_message(\"MQTT broker IP address format is invalid\")\n            )\n        )\n        .with_context(\"MQTT broker IP validation\")\n        .with_context(\"Messaging configuration validation\"));\n    }\n    \n    // Validate device ID\n    if DEVICE_ID.is_empty() {\n        return Err(IoTError::configuration(\n            ConfigError::MissingParameter(\n                utils::error_message(\"Device ID cannot be empty\")\n            )\n        )\n        .with_context(\"Device identification validation\")\n        .with_context(\"System configuration validation\"));\n    }\n    \n    rprintln!(\"   ✅ Configuration validation passed\");\n    Ok(())\n}\n\n/// Simple IP format validation\nfn is_valid_ip_format(ip: &str) -> bool {\n    // Basic check for IP format (not comprehensive)\n    let parts: heapless::Vec<&str, 4> = ip.split('.').collect();\n    \n    if parts.len() != 4 {\n        return false;\n    }\n    \n    for part in parts {\n        if let Ok(num) = part.parse::<u8>() {\n            if part.len() > 3 || (part.starts_with('0') && part.len() > 1) {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    \n    true\n}\n\n/// Demonstrate system-related errors\nasync fn demonstrate_system_errors() -> IoTResult<()> {\n    rprintln!(\"   🖥️ Testing system operations...\");\n    \n    // Simulate memory allocation check\n    let available_memory = get_available_memory_simulation();\n    if available_memory < 10000 {\n        return Err(IoTError::system(\n            SystemError::OutOfMemory(\n                utils::error_message(&format!(\"Only {}KB available, need at least 10KB\", available_memory / 1024))\n            )\n        )\n        .with_context(\"Memory availability check\")\n        .with_context(\"System resource validation\"));\n    }\n    \n    // Simulate serialization error\n    match simulate_json_serialization() {\n        Ok(()) => rprintln!(\"   ✅ JSON serialization successful\"),\n        Err(e) => return Err(e.with_context(\"Data serialization\")\n                           .with_context(\"Message formatting subsystem\")),\n    }\n    \n    Ok(())\n}\n\n/// Simulate memory check\nfn get_available_memory_simulation() -> u32 {\n    // Return a simulated low memory value to trigger error\n    8192  // 8KB\n}\n\n/// Simulate JSON serialization\nfn simulate_json_serialization() -> IoTResult<()> {\n    // Simulate serialization success/failure\n    // In real implementation, this would be actual JSON serialization\n    \n    // For demo, let's make it succeed\n    Ok(())\n}\n\n/// Demonstrate error recovery strategies\nasync fn demonstrate_error_recovery(stats: &mut ErrorStats) {\n    rprintln!(\"   🔄 Demonstrating error recovery strategies...\");\n    \n    stats.recovery_attempts += 1;\n    \n    // Recovery strategy 1: Retry with exponential backoff\n    rprintln!(\"   ⏰ Strategy 1: Exponential backoff retry\");\n    if retry_with_backoff(|| simulate_unreliable_operation(), 3).await {\n        rprintln!(\"   ✅ Recovery successful after retries\");\n        stats.successful_recoveries += 1;\n    } else {\n        rprintln!(\"   ❌ Recovery failed after all retries\");\n    }\n    \n    // Recovery strategy 2: Graceful degradation\n    rprintln!(\"   📉 Strategy 2: Graceful degradation\");\n    demonstrate_graceful_degradation().await;\n    \n    // Recovery strategy 3: Circuit breaker pattern\n    rprintln!(\"   🔌 Strategy 3: Circuit breaker pattern\");\n    demonstrate_circuit_breaker().await;\n}\n\n/// Retry operation with exponential backoff\nasync fn retry_with_backoff<F>(mut operation: F, max_retries: u32) -> bool\nwhere\n    F: FnMut() -> bool,\n{\n    for attempt in 1..=max_retries {\n        if operation() {\n            return true;\n        }\n        \n        let delay_ms = 100 * (2_u64.pow(attempt - 1));\n        rprintln!(\"     Attempt {} failed, retrying in {}ms...\", attempt, delay_ms);\n        Timer::after(Duration::from_millis(delay_ms)).await;\n    }\n    \n    false\n}\n\n/// Simulate unreliable operation\nfn simulate_unreliable_operation() -> bool {\n    // Simulate operation that succeeds on 3rd attempt\n    static mut ATTEMPT_COUNT: u32 = 0;\n    unsafe {\n        ATTEMPT_COUNT += 1;\n        ATTEMPT_COUNT >= 3\n    }\n}\n\n/// Demonstrate graceful degradation\nasync fn demonstrate_graceful_degradation() {\n    rprintln!(\"     Attempting primary operation...\");\n    \n    // Simulate primary operation failure\n    Timer::after(Duration::from_millis(100)).await;\n    rprintln!(\"     Primary operation failed, switching to fallback mode\");\n    \n    // Use cached data or alternative approach\n    rprintln!(\"     Using cached sensor data from previous reading\");\n    rprintln!(\"     Reduced functionality mode active\");\n}\n\n/// Demonstrate circuit breaker pattern\nasync fn demonstrate_circuit_breaker() {\n    static mut FAILURE_COUNT: u32 = 0;\n    const FAILURE_THRESHOLD: u32 = 3;\n    \n    unsafe {\n        if FAILURE_COUNT >= FAILURE_THRESHOLD {\n            rprintln!(\"     Circuit breaker OPEN - service temporarily disabled\");\n            rprintln!(\"     Waiting for recovery period...\");\n            Timer::after(Duration::from_millis(500)).await;\n            FAILURE_COUNT = 0;  // Reset for demo\n            rprintln!(\"     Circuit breaker HALF-OPEN - testing service\");\n        } else {\n            FAILURE_COUNT += 1;\n            rprintln!(\"     Operation failed ({}/{} threshold)\", FAILURE_COUNT, FAILURE_THRESHOLD);\n        }\n    }\n}\n\n/// Handle error with comprehensive context display\nfn handle_error_with_context(error: &IoTError, operation: &str, stats: &mut ErrorStats) {\n    rprintln!(\"   ❌ {} failed:\", operation);\n    rprintln!(\"      Error: {}\", error);\n    rprintln!(\"      Category: {}\", error.category());\n    rprintln!(\"      Error Code: {}\", error.error_code());\n    \n    // Show error kind-specific handling\n    match error.kind() {\n        IoTErrorKind::Sensor(_) => {\n            rprintln!(\"      🌡️ Sensor error detected - implementing sensor recovery\");\n            rprintln!(\"         - Checking sensor power and connections\");\n            rprintln!(\"         - Attempting sensor reset sequence\");\n            rprintln!(\"         - Using last known good calibration data\");\n        }\n        IoTErrorKind::Network(_) => {\n            rprintln!(\"      📡 Network error detected - implementing network recovery\");\n            rprintln!(\"         - Checking WiFi signal strength\");\n            rprintln!(\"         - Attempting reconnection with backoff\");\n            rprintln!(\"         - Switching to offline mode if needed\");\n        }\n        IoTErrorKind::Hardware(_) => {\n            rprintln!(\"      🔧 Hardware error detected - implementing hardware recovery\");\n            rprintln!(\"         - Checking power supply stability\");\n            rprintln!(\"         - Reinitializing peripherals\");\n            rprintln!(\"         - Running hardware diagnostics\");\n        }\n        IoTErrorKind::Configuration(_) => {\n            rprintln!(\"      ⚙️ Configuration error detected - implementing config recovery\");\n            rprintln!(\"         - Loading default configuration\");\n            rprintln!(\"         - Validating all parameters\");\n            rprintln!(\"         - Requesting user intervention if needed\");\n        }\n        IoTErrorKind::System(_) => {\n            rprintln!(\"      🖥️ System error detected - implementing system recovery\");\n            rprintln!(\"         - Checking available resources\");\n            rprintln!(\"         - Freeing unused memory\");\n            rprintln!(\"         - Considering system restart\");\n        }\n    }\n}\n\n/// Display comprehensive error statistics\nfn display_error_statistics(stats: &ErrorStats) {\n    rprintln!(\"\\n📊 === ERROR STATISTICS ===\");\n    rprintln!(\"   Total errors encountered: {}\", stats.total_errors);\n    rprintln!(\"   📊 Error breakdown:\");\n    rprintln!(\"      🌡️ Sensor errors: {}\", stats.sensor_errors);\n    rprintln!(\"      📡 Network errors: {}\", stats.network_errors);\n    rprintln!(\"      🔧 Hardware errors: {}\", stats.hardware_errors);\n    rprintln!(\"      ⚙️ Configuration errors: {}\", stats.config_errors);\n    rprintln!(\"      🖥️ System errors: {}\", stats.system_errors);\n    rprintln!(\"   🔄 Recovery attempts: {}\", stats.recovery_attempts);\n    rprintln!(\"   ✅ Successful recoveries: {}\", stats.successful_recoveries);\n    \n    if stats.recovery_attempts > 0 {\n        let recovery_rate = (stats.successful_recoveries * 100) / stats.recovery_attempts;\n        rprintln!(\"   📈 Recovery success rate: {}%\", recovery_rate);\n    }\n}\n\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo) -> ! {\n    rprintln!(\"💥 SYSTEM PANIC: {}\", info);\n    rprintln!(\"🔄 In a production system, this would trigger:\");\n    rprintln!(\"   - Error logging to persistent storage\");\n    rprintln!(\"   - Emergency data backup\");\n    rprintln!(\"   - System restart with recovery mode\");\n    rprintln!(\"   - Alert notification to monitoring systems\");\n    \n    loop {}\n}"